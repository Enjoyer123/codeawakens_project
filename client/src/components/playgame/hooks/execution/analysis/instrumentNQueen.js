/**
 * instrumentNQueen.js
 * 
 * Instrumentation and init code for the N-Queen backtracking algorithm.
 * Handles: code patching, stub removal, visual hooks, and init code generation.
 */

import * as Blockly from "blockly/core";
import { javascriptGenerator } from "blockly/javascript";

/**
 * Instruments N-Queen code by:
 * 1. Removing empty stub functions (safe, place, remove)
 * 2. Fixing solve function calls to map to proper helpers
 * 3. Extracting recursive case from workspace if missing
 */
export const instrumentNQueen = (code, currentLevel, workspaceRef) => {
    const hasSolve = code.includes('async function solve');
    const hasN = code.includes('var n') || code.includes('let n') || code.includes('n =') || code.includes('nqueen') || /\bn\b/.test(code);
    const hasBoard = code.includes('var board') || code.includes('let board') || code.includes('board[') || code.includes('board[i]') || code.includes('listVar = board') || code.includes('= board') || code.includes(' board') || /\bboard\b/.test(code);
    const isNQueenProblem = hasSolve && hasN && hasBoard;

    if (isNQueenProblem && !code.includes('for (let col')) {
        try {
            code = extractRecursiveCaseFromWorkspace(code, workspaceRef);
        } catch (e) {
            console.error('[instrumentNQueen] Error extracting recursive case from workspace:', e);
        }
    }

    if (isNQueenProblem) {
        code = removeStubFunctions(code);
        code = fixSolveFunctionCalls(code);
    }

    if (currentLevel?.nqueenData && code.includes('// Describe this function...')) {
        code = fixDefaultGeneratorOutput(code);
    }

    return code;
};

/**
 * Removes empty stub functions for safe, place, remove that Blockly generates.
 */
function removeStubFunctions(code) {
    code = code.replace(/\/\/\s*Check if placing queen.*?\n\s*async function safe\s*\([^)]*\)\s*\{[^}]*return false;?\s*\}/gs, '');
    code = code.replace(/\/\/\s*Place queen at.*?\n\s*(?:async\s+)?function place\s*\([^)]*\)\s*\{\s*\}/gs, '');
    code = code.replace(/\/\/\s*Remove queen from.*?\n\s*(?:async\s+)?function remove\s*\([^)]*\)\s*\{\s*\}/gs, '');
    code = code.replace(/async function safe\s*\([^)]*\)\s*\{\s*return false;?\s*\}/g, '');
    code = code.replace(/function safe\s*\([^)]*\)\s*\{\s*\}/g, '');
    code = code.replace(/(?:async\s+)?function place\s*\([^)]*\)\s*\{\s*\}/g, '');
    code = code.replace(/(?:async\s+)?function remove\s*\([^)]*\)\s*\{\s*\}/g, '');
    return code;
}

/**
 * Fixes solve(row, col) calls to map to safe/place/remove based on context.
 */
function fixSolveFunctionCalls(code) {
    code = code.replace(/if\s*\(\s*\(?\s*await\s+solve\d*\s*\(\s*row\s*,\s*col\s*\)/g, (match) =>
        match.includes('safe') || match.includes('place') || match.includes('remove')
            ? match : match.replace(/solve\d*/g, 'safe'));

    code = code.replace(/else\s*\{\s*await\s+solve\d*\s*\(\s*row\s*,\s*col\s*\)/g, (match) =>
        match.replace(/solve\d*/g, 'remove'));

    code = code.replace(/await\s+solve\d*\s*\(\s*row\s*,\s*col\s*\)\s*;/g, (match) =>
        (!match.includes('safe') && !match.includes('place') && !match.includes('remove'))
            ? match.replace(/solve\d*/g, 'place') : match);

    return code;
}

/**
 * Fixes code generated by Blockly's default generator output (has "Describe this function..." comment).
 */
function fixDefaultGeneratorOutput(code) {
    const funcNameMatch = code.match(/function\s+(solve\d*)\s*\(/);
    const funcName = funcNameMatch ? funcNameMatch[1] : 'solve';

    // Fix function definition: make async, remove 'col' param
    code = code.replace(new RegExp(`function\\s+(${funcName})\\s*\\([^)]*\\)\\s*\\{`, 'g'), (match, fName) => {
        const paramsMatch = match.match(/\(([^)]*)\)/);
        const originalParams = paramsMatch ? paramsMatch[1] : '';
        const correctParams = originalParams.split(',').map(p => p.trim()).filter(p => p !== 'col').join(', ');
        return `async function ${fName}(${correctParams}) {`;
    });

    // Fix function calls: remove 'col' argument
    const functionCallPattern = new RegExp(`(await\\s+)?\\b${funcName}\\b\\s*\\(([^)]*)\\)`, 'g');
    code = code.replace(functionCallPattern, (match, awaitKeyword, params) => {
        if (!params || params.trim().length === 0)
            return `${awaitKeyword ? awaitKeyword.trim() + ' ' : ''}${funcName}()`;
        const paramList = params.split(',').map(p => p.trim()).filter(p => p.length > 0);
        const filteredParams = paramList.filter(p => p.trim() !== 'col');
        const finalParams = filteredParams.length > 0 ? [filteredParams[0]] : ['row'];
        return `${awaitKeyword ? awaitKeyword.trim() + ' ' : ''}${funcName}(${finalParams.join(', ')})`;
    });

    // Fix solve(row, col) â†’ safe/place/remove
    code = code.replace(/if\s*\(\s*\(\s*await\s+solve(\d*)\s*\(\s*row\s*,\s*col\s*\)/g, `if ((await safe(row, col`);
    code = code.replace(/if\s*\(\s*await\s+solve(\d*)\s*\(\s*row\s*,\s*col\s*\)/g, (m) =>
        m.includes('safe') ? m : `if (await safe(row, col`);
    code = code.replace(/else\s*\{\s*await\s+solve(\d*)\s*\(\s*row\s*,\s*col\s*\)/g, `else { await remove(row, col`);
    code = code.replace(/await\s+solve(\d*)\s*\(\s*row\s*,\s*col\s*\)\s*;/g, (match, num, offset) => {
        const contextStart = Math.max(0, offset - 100);
        const contextEnd = Math.min(code.length, offset + match.length + 50);
        const context = code.substring(contextStart, contextEnd);
        if (context.includes('if') && !context.match(/;\s*if\s*\(/)) return match;
        if (context.includes('else') && !context.match(/else\s*\{[^}]*$/)) return match;
        return `await place(row, col);`;
    });

    // Ensure await before safe/place/remove calls
    code = code.replace(/(\b)(await\s+)?safe\s*\(/g, (m, b, a) => a ? m : `${b}await safe(`);
    code = code.replace(/(\b)(await\s+)?place\s*\(/g, (m, b, a) => a ? m : `${b}await place(`);
    code = code.replace(/(\b)(await\s+)?remove\s*\(/g, (m, b, a) => a ? m : `${b}await remove(`);

    // Ensure return solution exists in base case
    const hasReturnSolution = code.includes('return solution');
    const hasReturnSolutionInBaseCase = /if\s*\([^)]*row[^)]*n[^)]*\)\s*\{[\s\S]*?return solution/.test(code);

    if (!hasReturnSolution || !hasReturnSolutionInBaseCase) {
        code = injectReturnSolution(code);
    }

    return code;
}

/**
 * Injects 'return solution;' into the base case if missing.
 */
function injectReturnSolution(code) {
    const solutionPushIndex = code.indexOf('solution.push([i, j]);');
    if (solutionPushIndex === -1) return code;

    let recursiveCaseIndex = code.indexOf('for (let col', solutionPushIndex);
    if (recursiveCaseIndex === -1) recursiveCaseIndex = code.indexOf('const fromValue = 0;', solutionPushIndex);
    if (recursiveCaseIndex === -1) return code;

    const beforeRecursive = code.substring(solutionPushIndex, recursiveCaseIndex);
    let lastBraceIndex = -1;
    let braceCount = 0;
    for (let i = beforeRecursive.length - 1; i >= 0; i--) {
        if (beforeRecursive[i] === '}') {
            braceCount++;
            if (braceCount === 1) { lastBraceIndex = solutionPushIndex + i; break; }
        } else if (beforeRecursive[i] === '{') braceCount--;
    }

    if (lastBraceIndex !== -1) {
        const beforeBrace = code.substring(Math.max(0, lastBraceIndex - 200), lastBraceIndex);
        if (!beforeBrace.includes('return solution')) {
            code = code.substring(0, lastBraceIndex) + '\nreturn solution;\n' + code.substring(lastBraceIndex);
        }
    }

    return code;
}

/**
 * Extracts recursive case code from workspace blocks when generated code is missing it.
 */
function extractRecursiveCaseFromWorkspace(code, workspaceRef) {
    const solveBlocks = workspaceRef.current.getBlocksByType('procedures_defreturn', false);
    const solveBlock = solveBlocks.find(b =>
        b.getFieldValue('NAME') && b.getFieldValue('NAME').toLowerCase().includes('solve'));

    if (!solveBlock) return code;

    const stackBlock = solveBlock.getInputTargetBlock('STACK');
    if (!stackBlock || stackBlock.type !== 'if_only') return code;

    const actualNextBlock = findNextBlockAfterIf(stackBlock, workspaceRef);
    if (!actualNextBlock) return code;

    // Generate code from the found blocks
    let nextCode = '';
    let currentBlock = actualNextBlock;
    const processedIds = new Set();

    try {
        if (workspaceRef.current && javascriptGenerator.nameDB_ && workspaceRef.current.getVariableMap) {
            javascriptGenerator.nameDB_.setVariableMap(workspaceRef.current.getVariableMap());
        }
        if (typeof javascriptGenerator.init === 'function' && workspaceRef.current) {
            javascriptGenerator.init(workspaceRef.current);
        }
    } catch (e) { /* Generator init may fail - continue anyway */ }

    while (currentBlock && !processedIds.has(currentBlock.id)) {
        processedIds.add(currentBlock.id);
        try {
            const blockCode = javascriptGenerator.blockToCode(currentBlock);
            if (blockCode) {
                const codeStr = typeof blockCode === 'string' ? blockCode : (Array.isArray(blockCode) ? blockCode[0] : '');
                if (codeStr && codeStr.trim()) nextCode += codeStr;
            }
        } catch (e) { /* Skip blocks that fail to generate */ }
        if (currentBlock.nextConnection && currentBlock.nextConnection.targetBlock())
            currentBlock = currentBlock.nextConnection.targetBlock();
        else break;
    }

    if (!nextCode.trim()) return code;

    return injectRecursiveCaseCode(code, nextCode, workspaceRef);
}

/**
 * Finds the next block after an if_only block using multiple strategies.
 */
function findNextBlockAfterIf(stackBlock, workspaceRef) {
    // Strategy 1: Direct next connection
    let actualNextBlock = stackBlock.nextConnection?.targetBlock();
    if (actualNextBlock) return actualNextBlock;

    // Strategy 2: Target connection lookup
    if (stackBlock.nextConnection) {
        const targetConnection = stackBlock.nextConnection.targetConnection;
        if (targetConnection) {
            actualNextBlock = targetConnection.getSourceBlock();
            if (actualNextBlock) return actualNextBlock;
        }
    }

    // Strategy 3: Search all blocks for previous connection matching
    const allBlocks = workspaceRef.current.getAllBlocks(false);
    for (const block of allBlocks) {
        if (block.previousConnection) {
            const targetConn = block.previousConnection.targetConnection;
            if (targetConn) {
                const sourceBlock = targetConn.getSourceBlock ? targetConn.getSourceBlock() : (targetConn.sourceBlock_ || null);
                if (sourceBlock && sourceBlock.id === stackBlock.id) return block;
            }
        }
    }

    // Strategy 4: Find for_loop_dynamic with 'col' variable inside solve function
    for (const block of allBlocks) {
        if (block.type === 'for_loop_dynamic' && block.getFieldValue('VAR') === 'col') {
            let parent = block.getSurroundParent();
            while (parent) {
                if (parent.type === 'procedures_defreturn' && parent.getFieldValue('NAME')?.toLowerCase().includes('solve')) {
                    return block;
                }
                parent = parent.getSurroundParent();
            }
        }
    }

    return null;
}

/**
 * Injects the extracted recursive case code into the solve function.
 */
function injectRecursiveCaseCode(code, nextCode, workspaceRef) {
    const solveFuncMatch = code.match(/async\s+function\s+solve\s*\([^)]*\)\s*\{/);
    if (!solveFuncMatch) return code;

    const solveStartIndex = solveFuncMatch.index;

    // Find insertion point: before 'return null;' or at the end of the solve function
    let insertIndex = -1;
    const returnNullMatch = code.substring(solveStartIndex).match(/return\s+null\s*;/);
    if (returnNullMatch) {
        insertIndex = solveStartIndex + returnNullMatch.index;
    } else {
        let braceCount = 0;
        for (let i = solveStartIndex; i < code.length; i++) {
            if (code[i] === '{') braceCount++;
            else if (code[i] === '}') {
                braceCount--;
                if (braceCount === 0) { insertIndex = i; break; }
            }
        }
    }

    if (insertIndex === -1) return code;

    // Fix variable name collisions in injected code
    let fixedNextCode = nextCode;
    let fromValueCount = 0;
    fixedNextCode = fixedNextCode.replace(/\bconst\s+fromValue\s*=/g, () => {
        fromValueCount++;
        return fromValueCount === 1 ? 'const fromValueCol =' : `const fromValueCol${fromValueCount} =`;
    });
    let toValueCount = 0;
    fixedNextCode = fixedNextCode.replace(/\bconst\s+toValue\s*=/g, () => {
        toValueCount++;
        return toValueCount === 1 ? 'const toValueCol =' : `const toValueCol${toValueCount} =`;
    });
    fixedNextCode = fixedNextCode.replace(/\b(?:const|let|var)\s+listItems\s*=/g, 'const listItems_injected =');
    fixedNextCode = fixedNextCode.replace(/\blistItems\b/g, 'listItems_injected');
    fixedNextCode = fixedNextCode.replace(
        /for\s*\(\s*let\s+([A-Za-z_$][\w$]*)\s*=\s*fromValue\s*;\s*\1\s*<=\s*toValue\s*;\s*\1\+\+\s*\)/g,
        (m, varName) => `for (let ${varName} = 0; ${varName} <= (n - 1); ${varName}++)`
    );
    fixedNextCode = fixedNextCode.replace(/\b(?:const|let|var)\s+fromValue\s*=\s*0\s*;?/g, '');
    fixedNextCode = fixedNextCode.replace(/\b(?:const|let|var)\s+toValue\s*=\s*\(\s*n\s*-\s*1\s*\)\s*;?/g, '');

    // Fix variable name mappings
    const nVar = workspaceRef.current.getVariable('n');
    const boardVar = workspaceRef.current.getVariable('board');
    const solutionVar = workspaceRef.current.getVariable('solution');

    if (nVar) {
        const nGenName = javascriptGenerator.nameDB_.getName(nVar.getId(), Blockly.Names.NameType.VARIABLE);
        if (nGenName !== 'n') fixedNextCode = fixedNextCode.replace(new RegExp(`\\b${nGenName}\\b`, 'g'), 'n');
    }
    if (boardVar) {
        const boardGenName = javascriptGenerator.nameDB_.getName(boardVar.getId(), Blockly.Names.NameType.VARIABLE);
        if (boardGenName !== 'board') fixedNextCode = fixedNextCode.replace(new RegExp(`\\b${boardGenName}\\b`, 'g'), 'board');
    }
    if (solutionVar) {
        const solGenName = javascriptGenerator.nameDB_.getName(solutionVar.getId(), Blockly.Names.NameType.VARIABLE);
        if (solGenName !== 'solution') fixedNextCode = fixedNextCode.replace(new RegExp(`\\b${solGenName}\\b`, 'g'), 'solution');
    }

    // Inject the code
    const wrappedCode = '(function(){\n' + fixedNextCode + '\n})();';
    const markerComment = '\n/* const fromValue = 0; */\n';
    code = code.substring(0, insertIndex) + '\n' + markerComment + wrappedCode + '\n' + code.substring(insertIndex);

    // Clean up duplicate return statements
    try {
        let braceCount2 = 0;
        let solveEndIndex = -1;
        for (let i = solveStartIndex; i < code.length; i++) {
            if (code[i] === '{') braceCount2++;
            else if (code[i] === '}') {
                braceCount2--;
                if (braceCount2 === 0) { solveEndIndex = i; break; }
            }
        }
        if (solveEndIndex !== -1) {
            const funcBody = code.substring(solveStartIndex, solveEndIndex + 1);
            let cleaned = funcBody.replace(/return\s+null\s*;\s*/g, '');
            cleaned = cleaned.replace(/(?:return\s+solution\s*;\s*)+/g, 'return solution;\n');
            code = code.substring(0, solveStartIndex) + cleaned + code.substring(solveEndIndex + 1);
        }
    } catch (e) { /* Clean up best-effort */ }

    return code;
}

/**
 * Applies N-Queen visual transformations to the final executable code.
 * Protects function declarations, ensures async, and rewrites call sites to use globalThis.
 */
export const instrumentNQueenVisuals = (codeWithReturnCapture) => {
    try {
        // Protect function declarations for safe/place/remove during transformations
        codeWithReturnCapture = codeWithReturnCapture
            .replace(/async\s+function\s+place\s*\(/g, '__FUNC_PLACE_ASYNC__(')
            .replace(/function\s+place\s*\(/g, '__FUNC_PLACE__(')
            .replace(/async\s+function\s+remove\s*\(/g, '__FUNC_REMOVE_ASYNC__(')
            .replace(/function\s+remove\s*\(/g, '__FUNC_REMOVE__(')
            .replace(/async\s+function\s+safe\s*\(/g, '__FUNC_SAFE_ASYNC__(')
            .replace(/function\s+safe\s*\(/g, '__FUNC_SAFE__(');

        // Ensure solve functions are async
        codeWithReturnCapture = codeWithReturnCapture.replace(/(async\s+)?function\s+(solve)\s*\(/g, 'async function $2(');
        codeWithReturnCapture = codeWithReturnCapture.replace(/(\b)solve\s*=\s*(async\s+)?function\s*\(/g, 'solve = async function(');

        // Restore protected function definitions
        codeWithReturnCapture = codeWithReturnCapture
            .replace(/__FUNC_PLACE_ASYNC__\(/g, 'async function place(')
            .replace(/__FUNC_PLACE__\(/g, 'function place(')
            .replace(/__FUNC_REMOVE_ASYNC__\(/g, 'async function remove(')
            .replace(/__FUNC_REMOVE__\(/g, 'function remove(')
            .replace(/__FUNC_SAFE_ASYNC__\(/g, 'async function safe(')
            .replace(/__FUNC_SAFE__\(/g, 'function safe(');

        // Rewrite awaited call sites to use globalThis (avoid local scope shadowing)
        codeWithReturnCapture = codeWithReturnCapture
            .replace(/\bawait\s+safe\s*\(/g, 'await globalThis.safe(')
            .replace(/\bawait\s+place\s*\(/g, 'await globalThis.place(')
            .replace(/\bawait\s+remove\s*\(/g, 'await globalThis.remove(');

        // Default visual mode settings
        try {
            if (typeof globalThis !== 'undefined') {
                if (typeof globalThis.__nqueenVisual_mode === 'undefined') globalThis.__nqueenVisual_mode = true;
                if (typeof globalThis.__nqueenVisual_delay === 'undefined') globalThis.__nqueenVisual_delay = 300;
                if (typeof globalThis.__nqueenVisual_accumulate === 'undefined') globalThis.__nqueenVisual_accumulate = false;
            }
        } catch (e) { }

        return codeWithReturnCapture;
    } catch (e) {
        console.warn('[instrumentNQueenVisuals] Could not transform N-Queen code for visuals:', e);
        return codeWithReturnCapture;
    }
};

/**
 * Generates initialization code for N-Queen variables and helper functions.
 */
export const getNQueenInitCode = (currentLevel) => {
    if (!currentLevel?.nqueenData) return '';
    const n = currentLevel.nqueenData.n || 4;

    return `
      // Initialize N-Queen variables from level data
      var n = ${n};
      
      // Initialize board (2D array to track queen positions)
      var board = [];
      for (var i = 0; i < n; i++) {
        board[i] = [];
        for (var j = 0; j < n; j++) {
          board[i][j] = 0; // 0 = empty, 1 = queen
        }
      }
      
      // Helper function: Check if placing queen at (row, col) is safe
      async function safe(row, col) {
        // Visual hook: Thinking (Cyan for high contrast)
        try { if (globalThis.__nqueenVisual_api && typeof globalThis.__nqueenVisual_api.onConsider === 'function') globalThis.__nqueenVisual_api.onConsider(row, col, true); } catch(e){}
        await new Promise(r => setTimeout(r, 400));

        var isSafe = true;
        // Check column (loop up to row)
        for (var i = 0; i < row; i++) {
          if (board[i][col] === 1) isSafe = false;
        }
        
        // Check upper-left diagonal
        for (var i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
          if (board[i][j] === 1) isSafe = false;
        }
        
        // Check upper-right diagonal
        for (var i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
          if (board[i][j] === 1) isSafe = false;
        }
        
        // Visual hook: Result
        try { if (globalThis.__nqueenVisual_api && typeof globalThis.__nqueenVisual_api.onConsider === 'function') globalThis.__nqueenVisual_api.onConsider(row, col, isSafe); } catch(e){}
        
        await new Promise(r => setTimeout(r, isSafe ? 200 : 500));
        
        return isSafe;
      }
      
      // Helper function: Place queen at (row, col)
      async function place(row, col) {
        board[row][col] = 1;
        if (!globalThis.__capturedSolution) globalThis.__capturedSolution = [];
        globalThis.__capturedSolution.push([row, col]);
        
        try { if (globalThis.__nqueenVisual_api && typeof globalThis.__nqueenVisual_api.onPlace === 'function') globalThis.__nqueenVisual_api.onPlace(row, col); } catch(e){}
        await new Promise(r => setTimeout(r, 300));
      }
      
      // Helper function: Remove queen from (row, col)
      async function remove(row, col) {
        board[row][col] = 0;
        if (globalThis.__capturedSolution) {
           for(let i=globalThis.__capturedSolution.length-1; i>=0; i--) {
              if(globalThis.__capturedSolution[i][0]===row && globalThis.__capturedSolution[i][1]===col) {
                  globalThis.__capturedSolution.splice(i, 1);
                  break;
              }
           }
        }
        
        try { if (globalThis.__nqueenVisual_api && typeof globalThis.__nqueenVisual_api.onRemove === 'function') globalThis.__nqueenVisual_api.onRemove(row, col); } catch(e){}
        await new Promise(r => setTimeout(r, 300));
      }

      // Expose helpers to globalThis for Blockly-generated code
      try { globalThis.safe = safe; globalThis.place = place; globalThis.remove = remove; } catch (e) {}
    `;
};
